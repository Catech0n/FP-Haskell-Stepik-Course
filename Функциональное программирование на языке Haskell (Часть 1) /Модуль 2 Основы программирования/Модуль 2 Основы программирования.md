# Модуль 2 Основы программирования

## Урок 2.1 Параметрический полиморфизм

### [Шаг 2.1.2](https://stepik.org/lesson/8417/step/2?unit=1555)

Функция обладает полиморфным поведением, если она может быть вызвана на значениях разных типов. Пример полиморфной функции это оператор сложения.

Существует два типа полиморфных функций или два типа полиморфизма:
- Параметрический полиморфизм -- код функций одинаков для всех типов, на которых возможен вызов функции.
- Специальный полиморфизм -- код функции содержит реализации для каждого типа, на которых возможен вызов функции.

Пример простейшей параметрически полиморфной функции: `id x = x`

```haskell
> :t id
id :: t -> t

> id True
True

> id 5
5

> (id id) 4
4

> :t id True
id' True :: Bool

> :t (id id)
(id id) :: t -> t
```

`t` означает произвольный тип(переменная типа), вместо может быть подставлен любой тип. Имя этой переменной совершенно неважно(может быть как `t1` так `a` или `b`).

### [Шаг 2.1.3](https://stepik.org/lesson/8417/step/3?unit=1555)

Напишите функцию трех аргументов `getSecondFrom`, полиморфную по каждому из них, которая полностью игнорирует первый и третий аргумент, а возвращает второй. Укажите ее тип.

```haskell
GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42
```

#### Решение 2.1.3

```haskell
getSecondFrom :: a -> b -> c -> b
getSecondFrom fst snd trd = snd
```

### [Шаг 2.1.4](https://stepik.org/lesson/8417/step/4?unit=1555)

Сколько разных всегда завершающихся функций с типом `a -> a -> b -> a -> a` можно реализовать?

Две функции одинаковой арности считаются разными, если существует набор значений их аргументов, на котором они дают разные результирующие значения.

#### Решение 2.1.4

Количество стрелочек = количеству переменных. Тип возвращаемого значения `a`, поэтому подходящих под описание функций может только `3`:

```haskell
f a _ b _ = a
f _ a b _ = a
f _ _ b a = a
```

### [Шаг 2.1.5](https://stepik.org/lesson/8417/step/5?unit=1555)

Степень полиморфмизма функции возможно ограничить с помощью явного указания её типа.

```haskell
mono :: Char -> Char
mono x = x

semiMono :: Char -> a -> Char
semiMono x y = x
```

Функция `semiMono` мономорфна по первому аргументу и полиморфна по второму. 

Если не указывать типы явно, то Haskell вывод наиболее общий тип:
- Было: `semiMono :: Char -> a -> Char`
- Стало: `semiMono :: t1 -> t -> t1`

Система вывода типов в Haskell базируется на системе типов Хиндли — Милнера.

### [Шаг 2.1.6](https://stepik.org/lesson/8417/step/6?unit=1555)

Функция высших порядок это функция, которая принимает в качестве аргумента другую функцию.

```haskell
> :t ($)
($) :: (a -> b) -> a -> b
```

Оператор `$` это функция высшего порядка. Она полиморфна.

---

Функция `apply2 f x = f (f x)`

```haskell
> :t apply2
apply2 :: (t -> t) -> t -> t

> apply2 (+ 5) 22
32

> apply2 (++ "AB") "CD"
"CDABAB"
```

---

Функция `flip f x y = f y x`

```haskell
> flip (/) 4 2
0.5

> (/) 4 2
2.0

> flip const 5 True
True

> :t flip
flip :: (a -> b -> c) -> b -> a -> c

> :t flip const
flip const :: b -> c -> c
```

### [Шаг 2.1.7](https://stepik.org/lesson/8417/step/7?unit=1555)

В модуле `Data.Function` определена полезная функция высшего порядка

```haskell
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
on op f x y = f x `op` f y
```

Она принимает четыре аргумента: бинарный оператор с однотипными аргументами (типа `b`), функцию `f :: a -> b`, возвращающую значение типа `b`, и два значения типа `a`. Функция `on` применяет `f` дважды к двум значениям типа `a` и передает результат в бинарный оператор.

Используя `on` можно, например, записать функцию суммирования квадратов аргументов так:

```haskell
sumSquares = (+) `on` (^2)
```

Функция `multSecond`, перемножающая вторые элементы пар, реализована следующим образом

```haskell
multSecond = g `on` h

g = undefined

h = undefined
```

Напишите реализацию функций `g` и `h`.

```haskell
GHCi> multSecond ('A',2) ('E',7)
14
```

#### Решение 2.1.7

```haskell
import Data.Function

multSecond = g `on` h

g = (*)

h = snd
```

### [Шаг 2.1.8](https://stepik.org/lesson/8417/step/8?unit=1555)

Тема: Анонимные функции или лямбда-функции.

```haskell
f x = 2 * x + 7

> f 10
27
```

Тоже самое можно записать в виде анонимной функции: 

```haskell
\x -> 2 * x + 7

> (\x -> 2 * x + 7) 10
27
```

Можно определить функцию `f'` с помощью лямбда-функции: `f' = \x -> 2 * x + 7`

---

Лямбда-функция многих переменных

```haskell
lenVec x y = sqrt $ x ^ 2 + y ^ 2

lenVec' x = \y -> sqrt $ x ^ 2 + y ^ 2

lenVec'' = \x -> \y -> sqrt $ x ^ 2 + y ^ 2
-- Итоговый вариант:
lenVec''' = \x y -> sqrt $ x ^ 2 + y ^ 2
```

---

```haskell
p1 = ((1, 2), (3, 4))

p2 = ((3, 4), (5, 6))

> fst $ fst p1
1
```

Функция суммирования первых элементов:
```haskell
import Data.Function
sumFstFst = (+) `on` helper
  where
    helper pp = fst $ fst pp

> sumFstFst p1 p2
4
```

Или тоже самое с помощью анонимной функции:

```haskell
import Data.Function
sumFstFst' = (+) `on` \pp -> fst $ fst pp

> sumFstFst' p1 p2
4
```

### [Шаг 2.1.9](https://stepik.org/lesson/8417/step/9?unit=1555)

Реализуйте функцию `on3`, имеющую семантику, схожую с `on`, но принимающую в качестве первого аргумента трехместную функцию:

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = undefined
```

Например, сумма квадратов трех чисел может быть записана с использованием `on3` так

```haskell
GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
GHCi> sum3squares 1 2 3
14
```

#### Решение 2.1.9

Почему нельзя `on3 op f x y z = op $ f x $ f y $ f z`? Если раскрыть `$`, то получится совсем другое выражение `op (f x (f y (f z)))`.

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x) (f y) (f z)
```

Через `where`

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op a b c where a = f x 
                                b = f y 
                                c = f z
```
