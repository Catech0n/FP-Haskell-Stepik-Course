# Модуль 2 Основы программирования

## Урок 2.1 Параметрический полиморфизм

### [Шаг 2.1.2](https://stepik.org/lesson/8417/step/2?unit=1555)

Функция обладает полиморфным поведением, если она может быть вызвана на значениях разных типов. Пример полиморфной функции это оператор сложения.

Существует два типа полиморфных функций или два типа полиморфизма:
- Параметрический полиморфизм -- код функций одинаков для всех типов, на которых возможен вызов функции.
- Специальный полиморфизм -- код функции содержит реализации для каждого типа, на которых возможен вызов функции.

Пример простейшей параметрически полиморфной функции: `id x = x`

```haskell
> :t id
id :: t -> t

> id True
True

> id 5
5

> (id id) 4
4

> :t id True
id' True :: Bool

> :t (id id)
(id id) :: t -> t
```

`t` означает произвольный тип(переменная типа), вместо может быть подставлен любой тип. Имя этой переменной совершенно неважно(может быть как `t1` так `a` или `b`).

### [Шаг 2.1.3](https://stepik.org/lesson/8417/step/3?unit=1555)

Напишите функцию трех аргументов `getSecondFrom`, полиморфную по каждому из них, которая полностью игнорирует первый и третий аргумент, а возвращает второй. Укажите ее тип.

```haskell
GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42
```

#### Решение 2.1.3

```haskell
getSecondFrom :: a -> b -> c -> b
getSecondFrom fst snd trd = snd
```

### [Шаг 2.1.4](https://stepik.org/lesson/8417/step/4?unit=1555)

Сколько разных всегда завершающихся функций с типом `a -> a -> b -> a -> a` можно реализовать?

Две функции одинаковой арности считаются разными, если существует набор значений их аргументов, на котором они дают разные результирующие значения.

#### Решение 2.1.4

Количество стрелочек = количеству переменных. Тип возвращаемого значения `a`, поэтому подходящих под описание функций может только `3`:

```haskell
f a _ b _ = a
f _ a b _ = a
f _ _ b a = a
```

### [Шаг 2.1.5](https://stepik.org/lesson/8417/step/5?unit=1555)

Степень полиморфмизма функции возможно ограничить с помощью явного указания её типа.

```haskell
mono :: Char -> Char
mono x = x

semiMono :: Char -> a -> Char
semiMono x y = x
```

Функция `semiMono` мономорфна по первому аргументу и полиморфна по второму. 

Если не указывать типы явно, то Haskell вывод наиболее общий тип:
- Было: `semiMono :: Char -> a -> Char`
- Стало: `semiMono :: t1 -> t -> t1`

Система вывода типов в Haskell базируется на системе типов Хиндли — Милнера.

### [Шаг 2.1.6](https://stepik.org/lesson/8417/step/6?unit=1555)

Функция высших порядок это функция, которая принимает в качестве аргумента другую функцию.

```haskell
> :t ($)
($) :: (a -> b) -> a -> b
```

Оператор `$` это функция высшего порядка. Она полиморфна.

---

Функция `apply2 f x = f (f x)`

```haskell
> :t apply2
apply2 :: (t -> t) -> t -> t

> apply2 (+ 5) 22
32

> apply2 (++ "AB") "CD"
"CDABAB"
```

---

Функция `flip f x y = f y x`

```haskell
> flip (/) 4 2
0.5

> (/) 4 2
2.0

> flip const 5 True
True

> :t flip
flip :: (a -> b -> c) -> b -> a -> c

> :t flip const
flip const :: b -> c -> c
```

### [Шаг 2.1.7](https://stepik.org/lesson/8417/step/7?unit=1555)

В модуле `Data.Function` определена полезная функция высшего порядка

```haskell
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
on op f x y = f x `op` f y
```

Она принимает четыре аргумента: бинарный оператор с однотипными аргументами (типа `b`), функцию `f :: a -> b`, возвращающую значение типа `b`, и два значения типа `a`. Функция `on` применяет `f` дважды к двум значениям типа `a` и передает результат в бинарный оператор.

Используя `on` можно, например, записать функцию суммирования квадратов аргументов так:

```haskell
sumSquares = (+) `on` (^2)
```

Функция `multSecond`, перемножающая вторые элементы пар, реализована следующим образом

```haskell
multSecond = g `on` h

g = undefined

h = undefined
```

Напишите реализацию функций `g` и `h`.

```haskell
GHCi> multSecond ('A',2) ('E',7)
14
```

#### Решение 2.1.7

```haskell
import Data.Function

multSecond = g `on` h

g = (*)

h = snd
```

### [Шаг 2.1.8](https://stepik.org/lesson/8417/step/8?unit=1555)

Тема: Анонимные функции или лямбда-функции.

```haskell
f x = 2 * x + 7

> f 10
27
```

Тоже самое можно записать в виде анонимной функции: 

```haskell
\x -> 2 * x + 7

> (\x -> 2 * x + 7) 10
27
```

Можно определить функцию `f'` с помощью лямбда-функции: `f' = \x -> 2 * x + 7`

---

Лямбда-функция многих переменных

```haskell
lenVec x y = sqrt $ x ^ 2 + y ^ 2

lenVec' x = \y -> sqrt $ x ^ 2 + y ^ 2

lenVec'' = \x -> \y -> sqrt $ x ^ 2 + y ^ 2
-- Итоговый вариант:
lenVec''' = \x y -> sqrt $ x ^ 2 + y ^ 2
```

---

```haskell
p1 = ((1, 2), (3, 4))

p2 = ((3, 4), (5, 6))

> fst $ fst p1
1
```

Функция суммирования первых элементов:
```haskell
import Data.Function
sumFstFst = (+) `on` helper
  where
    helper pp = fst $ fst pp

> sumFstFst p1 p2
4
```

Или тоже самое с помощью анонимной функции:

```haskell
import Data.Function
sumFstFst' = (+) `on` \pp -> fst $ fst pp

> sumFstFst' p1 p2
4
```

### [Шаг 2.1.9](https://stepik.org/lesson/8417/step/9?unit=1555)

Реализуйте функцию `on3`, имеющую семантику, схожую с `on`, но принимающую в качестве первого аргумента трехместную функцию:

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = undefined
```

Например, сумма квадратов трех чисел может быть записана с использованием `on3` так

```haskell
GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
GHCi> sum3squares 1 2 3
14
```

#### Решение 2.1.9

Почему нельзя `on3 op f x y z = op $ f x $ f y $ f z`? Если раскрыть `$`, то получится совсем другое выражение `op (f x (f y (f z)))`.

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x) (f y) (f z)
```

Через `where`

```haskell
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op a b c where a = f x 
                                b = f y 
                                c = f z
```

## Урок 2.2 Параметрический полиморфизм (2)

### [Шаг 2.2.2](https://stepik.org/lesson/12398/step/2?unit=2828)

Оператор композиции.

```haskell
compose f g = \x -> f (g x)

> :t compose
compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
```

В Haskell есть встроенный оператор композиции `(.)`, его тип `(.) :: (b -> c) -> (a -> b) -> a -> c` и infixr 9(приоритет 9 и правоассоциативен).

Реализацию `sumFstFst` из 2.1.8 можно переписать при помощи оператора композиции:

```haskell
import Data.Function

sumFstFst = (+) `on` helper
  where
    helper pp = fst $ fst pp

sumFstFst' = (+) `on` \pp -> fst $ fst pp

sumFstFst'' = (+) `on` (fst . fst)
```

---

Цепочка последовательных применений может быть заменена композицией

```
doIt x = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x
doIt   = f . g . h
```

### [Шаг 2.2.3](https://stepik.org/lesson/12398/step/3?unit=2828)

Функция одной переменной `doItYourself` выбирает наибольшее из переданного ей аргумента и числа 42, затем возводит результат выбора в куб и, наконец, вычисляет логарифм по основанию 2 от полученного числа. Эта функция реализована в виде:

```haskell
doItYourself = f . g . h
```

Напишите реализации функций `f`, `g` и `h`. Постарайтесь сделать это в бесточечном стиле.

f = undefined

g = undefined

h = undefined

#### Решение 2.2.3

Для удобства вызов функции можно переписать как `doItYourself x = f . g . h x`. Так проще понять в каком порядке и куда записывать определения функций.

```haskell
doItYourself = f . g . h

h :: Double -> Double
f = logBase 2

h :: Double -> Double
g = (^ 3)

h :: Double -> Double
h = max 42 
```

### [Шаг 2.2.4](https://stepik.org/lesson/12398/step/4?unit=2828)

Списки и кортежи тоже параметрически полиморфны. Степень полиморфизма кортежей выше чем у списков.

### [Шаг 2.2.5](https://stepik.org/lesson/12398/step/5?unit=2828)

Сколько разных всегда завершающихся функций с типом `a -> (a,b) -> a -> (b,a,a)` можно реализовать?

#### Решение 2.2.5

Задача схожа с 2.1.4

---

`x0, x1 и x2` имеют тип `а`, а `y0` тип `b`.

```haskell
f1 x0 (x1, y0) x2 = (y0, x0, x0)
f2 x0 (x1, y0) x2 = (y0, x0, x1)
f3 x0 (x1, y0) x2 = (y0, x0, x2)
f4 x0 (x1, y0) x2 = (y0, x1, x0)
f5 x0 (x1, y0) x2 = (y0, x1, x1)
f6 x0 (x1, y0) x2 = (y0, x1, x2)
f7 x0 (x1, y0) x2 = (y0, x2, x0)
f8 x0 (x1, y0) x2 = (y0, x2, x1)
f9 x0 (x1, y0) x2 = (y0, x2, x2)
```

Всего таких функций можно составить 9 штук.

### [Шаг 2.2.6](https://stepik.org/lesson/12398/step/6?unit=2828)

Комбинатор `on` требует каррированную функцию, т.е. `fst 'on' (^2)` приведёт к ошибке. Чтобы избежать этого нужно каррировать функцию `fst`, т.е. `carry fst 'on' (^2)`.

Функция `avg` не является каррированной функцией и её тоже необходимо каррировать перед использованием, т.е.  `carry avg 'on' (^2)`.

```haskell
avg :: (Double, Double) -> Double
avg p = (fst p + snd p) / 2
```

---

Как устрона функция `carry`? `carry f x y = f (x, y)` и её тип `curry :: ((a, b) -> c) -> a -> b -> c`. Есть и обратная функция `uncarry` и она принимает каррированную функцию и возвращает некаррированную `uncurry :: (a -> b -> c)-> (a, b) -> c`

### Шаг 2.2.7

Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `curry id`?

#### Решение 2.2.7

```haskell
> :t curry id
curry id :: a -> b -> (a, b)

> :t  (,)
(,) :: a -> b -> (a, b)
```

`(,)`

### Шаг 2.2.8

Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `uncurry (flip const)`?

#### Решение 2.2.8

```haskell
> :t uncurry (flip const)
uncurry (flip const) :: (b, c) -> c

> :t snd 
snd :: (a, b) -> b
```

### Шаг 2.2.9

В модуле `Data.Tuple` стандартной библиотеки определена функция `swap :: (a,b) -> (b,a)`, переставляющая местами элементы пары:

```haskell
GHCi> swap (1,'A')
('A',1)
```

Эта функция может быть выражена в виде:

```haskell
swap = f (g h)
```

где `f`, `g` и `h` — некоторые идентификаторы из следующего набора:

```
curry uncurry flip (,) const
```

Укажите через запятую подходящую тройку `f,g,h`.

#### Решение 2.2.9

```haskell
f = uncurry
g = flip
h = (,) 

swap = f (g h)

--

> :t swap
swap :: (b, a) -> (a, b)
```

`uncurry,flip,(,)`
