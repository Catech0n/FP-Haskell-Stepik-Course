# Модуль 1 Введение

## Урок 1.1 Установка и настройка среды

Критерии сдачи курса: для обычного сертификата достаточно набрать 140 баллов, для сертификата с отличием – 200 баллов.

### [Шаг 1.1.2](https://stepik.org/lesson/8119/step/2?unit=1375)

- Haskell Platform
  - Компилятор GHC == Glasgow Haskell Compiler
  - REPL интерпретатор GHCi == Glasgow Haskell Compiler interpreter
- Исходный код имеет расширение `.hs`
- Табуляция Tab(\t) равна 8 пробелов независимо от настроек редактора

### [Шаг 1.1.3](https://stepik.org/lesson/8119/step/3?unit=1375)

- Язык Haskell — чистый функциональный язык программирования с «ленивой» семантикой исполнения и полиморфной статической типизацией.
- Язык назван в честь американского логика и математика Хаскелла Брукса Карри.
- [Официальный сайт](https://www.haskell.org/)
- Справку по функциям стандартной библиотеки можно получить с помощью [Hoogle](https://www.haskell.org/hoogle/)

### [Шаг 1.1.4](https://stepik.org/lesson/8119/step/4?unit=1375)

- На момент разработки курса последней версией была Haskell Platform 2014.2.0.0
- Версия компилятора GHC 7.8.2 используется для проверки домашних заданий

На данный момент(с 2022 года) от Haskell Platform отказались.

### [Шаг 1.1.5](https://stepik.org/lesson/8119/step/5?unit=1375)

- Для запуска интерпретатора в командной строке `ghci`
- Чтобы поменять приглашение командной строке нужно набрать `:set prompt "GHCi>"`. 
  - ! Переопределение скрывает имя загруженного модуля

### [Шаг 1.1.6](https://stepik.org/lesson/8119/step/6?unit=1375)

Запустите ваш текстовой редактор и создайте файл `Hello.hs`, содержащий следующую строку кода:

```haskell
main = putStrLn "Hello, world!"
```

Вызовите теперь с помощью средств вашей ОС интерпретатор GHCi c параметром — именем файла исходного кода:

```haskell
ghci Hello.hs
```

(Файл должен располагаться в том же каталоге, откуда происходит вызов интерпретатора.) Проверьте, что загрузка модуля прошла успешно, вызвав в интерпретаторе определенную вами функцию `main`:

```haskell
GHCi> main
Hello, world!
```

Какое приглашение на самом деле выдает командная строка интерпретатора (в предыдущем примере интерпретатор выдал приглашение `GHCi> `)?

#### Решение 1.1.6

```haskell
*Main>
```

### [Шаг 1.1.7](https://stepik.org/lesson/8119/step/7?unit=1375)

- Чтобы в уже запущенный интерпретатор подгрузить модуль нужно использовать `:load moduleName` или `:l moduleName`, сократив до первой буквы.
- Чтобы перезагрузить модуль после внесения изменений в него нужно использовать `:reload moduleName`

## Урок 1.2 Функции

### [Шаг 1.2.2](https://stepik.org/lesson/7859/step/2?unit=1351)

В языке Haskell программа представляет из себя некоторое выражение, а выполнение программы это последовательные редукции этого выражения до состояния, когда никаких редукций совершить нельзя. 

Пример последовательности редукций:

```
(5 + 4 * 3) ^ 2
    Первая редукция ~> (5 + 12) ^ 2
    Вторая редукция ~> 17 ^ 2
    Третья и окончательная редукция ~> 289
```

`~>` обозначение шага редукции

### [Шаг 1.2.3](https://stepik.org/lesson/7859/step/3?unit=1351)

Следующий синтаксис двух последовательных идентификаторов обозначает применение `foo bar`, т.е. `foo` применяется к `bar`.

Скобки используются для группировки аргументов 

```haskell
{-
Вычисление arccos (cos pi) == pi
Сначала cos pi, а потом уже arccos от результата.
-}

> acos (cos pi)
3.141592653589793
```

Вызов функций двух аргументов `f x y`, где `f` функция, а `x` и `y` её аргументы. `max 5 42` вернёт `42`

### [Шаг 1.2.4](https://stepik.org/lesson/7859/step/4?unit=1351)

`max 5 42` вернёт `42` можно записать как `(max 5) 42` и тоже вернёт `42` -- операция применения функции ассоциативна влево. `(max 5)` называется частичным применением функции, результат работы выражения функция одного аргумента и может быть применена там, где требуется функция одного аргумента. 

В общем виде частичное применение функций можно сформулировать как применение функции от n переменных, но с точки зрения функции от одной переменной, но применённой n раз. Каждое применение такой функции будет возвращать функцию от n - 1 переменной.

### [Шаг 1.2.5](https://stepik.org/lesson/7859/step/5?unit=1351)

В стандартной библиотеке Haskell есть функция вычисления логарифма по произвольному основанию `logBase`. Это функция двух переменных, которой требуется передать основание логарифма и аргумент, на котором логарифм будет вычислен. Какие из следующих вызовов обеспечат вычисление логарифма по основанию 2 от 8?

- [+] (logBase 2) 8
- [-] logBase (2 8)
- [-] logBase (2, 8)
- [+] logBase 2 8
- [-] (logBase, 2, 8)

### [Шаг 1.2.6](https://stepik.org/lesson/7859/step/6?unit=1351)

Чтобы определить функцию нужно: задать её имя, указать параметры, поставить знак равенства и после знака равенства реализовать тело функции. Пример функции:

```haskell
sumSquares x y = x ^ 2 + y ^ 2
```

Регистр важен. Имя функции и параметры должны начинаться с символа в нижнем регистре. Символы в вернхнем регистре служат для определения типов данных.

В Haskell возможны имена включащие в себя `'`

Чтобы определить функцию в GHCi нужно использовать ключевое слово `let` перед именем функции.

### [Шаг 1.2.7](https://stepik.org/lesson/7859/step/7?unit=1351)

Реализуйте функцию трех аргументов `lenVec3`, которая вычисляет длину трехмерного вектора. Аргументы функции задают декартовы координаты конца вектора, его начало подразумевается находящимся в начале координат. Для извлечения квадратного корня воспользуйтесь функцией `sqrt`, определенной в стандартной библиотеке.

```haskell
GHCi> lenVec3 2 3 6
7.0
```

#### Решение 1.2.7

```haskell
lenVec3 x y z =  sqrt (x ^ 2 + y ^ 2 + z ^ 2)
```

### [Шаг 1.2.8](https://stepik.org/lesson/7859/step/8?unit=1351)

Важная отличительна черта функциональных языков это чистые функции. Функции чистые, т.е. не имеют внешних эффектов и определяются только её аргументами.

Функция, которая не принимает аргументов, это константа или константная функция. 

### [Шаг 1.2.9](https://stepik.org/lesson/7859/step/9?unit=1351)

Пример условного выражения `f x = if x > 0 then 1 else (-1)`

Отрицательные числа следует заключать в скобки

В Haskell обе ветви условного выражения должны присутствовать. В ветвях должны быть выражения одного и того же типа. 

### [Шаг 1.2.10](https://stepik.org/lesson/7859/step/10?unit=1351)

Напишите реализацию функции `sign`, которая возвращает 1, если ей передано положительное число, (-1), если отрицательное, и 0 в случае, когда передан 0.

```haskell
GHCi> sign (-100)
-1
```

#### Решение 1.2.10

```haskell
sign x = if x > 0 then 1 else if x == 0 then 0 else (-1)
```

### [Шаг 1.2.11](https://stepik.org/lesson/7859/step/11?unit=1351)

Механизм определения функций с помощью частичного применения

```haskell
max5 x = max 5 x
--- Эквивалентен
max5` = max 5 
--- max5' это частично применённая функция max
```

Подобный стиль называется бесточечным.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

В Haskell часто специально проектируют функции, чтобы их было проще применять частично. В функции `discount` параметры `proc` и `limit` меняются крайне редко, а вот `sum` постоянно.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
--- Функция определения стандартной скидки.
standardDiscount = discount 1000 5
```

Функция `standardDiscount` определена как частичная, т.к. параметр `sum` опущен. Теперь Функция `standardDiscount` может быть вызвана с одним параметром. 

### [Шаг 1.2.12](https://stepik.org/lesson/7859/step/12?unit=1351)

Предположим, мы разрабатываем на Haskell интерфейс системы перевода для естественных языков. Он должен содержать функцию `translate` с параметрами `text`, `languageFrom` и `languageTo`. Расположите параметры в таком порядке, чтобы было удобно реализовывать следующие функции: `translateFromSpanishToRussian`, `translateFromEnglishToRussian` и `translateToRussian`.

- [+] translate languageTo languageFrom text
- translate text languageFrom languageTo
- translate languageTo text languageFrom
- translate languageFrom languageTo text
- translate text languageTo languageFrom
- translate languageFrom text languageTo

Поставить параметр `languageTo` первым, т.к. все три функции переводят на русский язык.

Поставить параметр `languageFrom` вторым, т.к. `FromSpanish`, `FromEnglish` и в последнем язык случае с какого языка будет происходить перевод вообще явно не определён.

Поставить параметр `text` в конце, т.к. он постоянно меняется. Частичное применение. 

## Урок 1.3 Операторы

### [Шаг 1.3.2](https://stepik.org/lesson/8411/step/2?unit=1550)

Функции вызываются в префиксном стиле, т.е. функция идёт перед своими аргументами, а операторы в инфиксном стиле, т.е. оператор находится между своими аргументами. Это различие можно убрать и начать вызывать операторы в префиксном стиле и функции в инфиксном. Для этого нужно поместить функцию между аргументами и заключить в обратные ковычки, операторы нужно заключить в скобки и поставить перед аргументами. 

```haskell
max 6 7
6 `max` 7
--
6 + 7
(+) 6 7
```

Все операторы в Haskell бинарные, т.е. принимают два аргумента. Кроме унарного префиксного минуса, который служить для создания отрицательных чисел.

### [Шаг 1.3.3](https://stepik.org/lesson/8411/step/3?unit=1550)

Применение функции имеет наивысший приоритет равный 10.

Для установки приоритета и ассоциативность служат следующие ключевые слова:
- `infixl` -- левоассоциативность
- `infixr` -- правоассоциативность
- `infix` -- без указания характера ассоциативности
- затем указывается число от 1 до 10
- и в конце имя оператора

```haskell
-- Пример из стандартной библиотеки 
infixr 8 ^, `logBase`
infixl 7 *, /, `div`, `mod`
infixl 6 +, -
infix 4 ==, /=, >, >=, <, <=
```

По-умолчанию в Haskell принята левоассоциативность и приоритет 9.

### [Шаг 1.3.4](https://stepik.org/lesson/8411/step/4?unit=1550)

Попробуйте вычислить значение выражения `2 ^ 3 ^ 2`, не используя GHCi.

#### Решение 1.3.4

```
2 ^ 3 ^ 2
~> 2 ^ 9
~> 512
```

### [Шаг 1.3.5](https://stepik.org/lesson/8411/step/5?unit=1550)

Попробуйте вычислить значение выражения `(*) 2 ((+) 1 4) ^ 2`, не используя GHCi.

#### Решение 1.3.5

```
(*) 2 ((+) 1 4) ^ 2
~> (*) 2 5 ^ 2
~> 10 ^ 2 = 100
```

### [Шаг 1.3.6](https://stepik.org/lesson/8411/step/6?unit=1550)

В Haskell нет встроенных операторов. 

Список символов, из которых можно составить собственные операторы: `! # $ % & * + . / < = > & @ \ ^ | - ~`

Пример собственного оператора: 

```haskell
infixl 6 *+*

-- В инфиксной нотации или операторном стиле
a *+* b = a ^ 2 + b ^ 2
-- В префиксной нотации или в функциональном стиле
(*+*) a b = a ^ 2 + b ^ 2
```

### [Шаг 1.3.7](https://stepik.org/lesson/8411/step/7?unit=1550)

Используя данное выше определение оператора `(*+*)`:

```haskell
infixl 6 *+*
(*+*) a b = a ^ 2 + b ^ 2
```

попробуйте устно вычислить значение выражения `1 + 3 *+* 2 * 2`.

#### Решение 1.3.7

```
1 + 3 *+* 2 * 2
~> 1 + 3 *+* 4
~> 4 *+* 4 
~> 4 ^ 2 + 4 ^ 2 = 16 + 16 = 32
```

### [Шаг 1.3.8](https://stepik.org/lesson/8411/step/8?unit=1550)

Реализуйте оператор `|-|`, который возвращает модуль разности переданных ему аргументов:

```haskell
GHCi>  5 |-| 7
2
```

#### Решение 1.3.8

```haskell
{-
Реализуйте оператор |-|, который возвращает модуль разности переданных ему аргументов:

GHCi>  5 |-| 7
2
-}
x |-| y = if x - y >= 0 then x - y else y - x
-- x |-| y = abs (x - y)
```

### [Шаг 1.3.9](https://stepik.org/lesson/8411/step/9?unit=1550)

Специальный компактный синтаксис частичного применения оператора к одному из своих аргументов.

```haskell
-- Сечение оператора. Связывание слева.
(2 /) 4
-- Вернёт 0.5 как ожидалось.

-- Сечение оператора. Связывание справа.
(/ 2) 4
-- Вернёт 2.0 как ожидалось.
```

Подобный синтаксис требует обязательного использования круглых скобок. Оператор унарный минус `(-)` является исключением.

### [Шаг 1.3.10](https://stepik.org/lesson/8411/step/10?unit=1550)

Попробуйте вычислить значение выражения `('mod' 14) ((+ 5) 10)`, не используя GHCi. (Функция `mod` возвращает остаток от целочисленного деления первого своего аргумента на второй.)

#### Решение 1.3.10

```
('mod' 14) ((+ 5) 10)
~> ('mod' 14) 15
~> 15 mod 14 = 1
```

### [Шаг 1.3.11](https://stepik.org/lesson/8411/step/11?unit=1550)

Оператор `$`. Его приоритет равен 0 и правоассоциативный. Он используется для избавления от избыточных скобок. 

Записи `sin 0` и `sin $ 0` эквивалетны.

Запись `sin (pi / 2)` можно упростить с помощью оператора `$` и записать как `sin $ pi / 2`.

`f (g x (h y))` == `f $ g x (h y)` == `f $ g x $ h y`

### [Шаг 1.3.12](https://stepik.org/lesson/8411/step/12?unit=1550)

Используя оператор `$`, перепишите выражение `logBase 4 (min 20 (9 + 7))` без скобок. (Разделяйте все токены одним пробелом.)

#### Решение 1.3.12

```haskell
logBase 4 $ min 20 $ 9 + 7
```

## Урок 1.4 Базовые типы

### [Шаг 1.4.2](https://stepik.org/lesson/8412/step/2?unit=1551)

Haskell имеет строгую статическую систему типов это значит, что отсутствуют неявные приведения типов, проверка типов происходит во время компиляции, а не во время исполнения.

В `ghci` можно узнать тип с помощью команды `:type`

```haskell
> :type 'c'
'c' :: Char
> :type '\n'
'\n' :: Char
> :type True
True :: Bool
> :type False
False :: Bool
```

### [Шаг 1.4.3](https://stepik.org/lesson/8412/step/3?unit=1551)

```haskell
> :type 3
3 :: Num a => a
```

Чтобы явно указать тип нужно применить оператора `::`

```haskell
> let x = 3 :: Int
> x
3
> :type x
x :: Int
> let y = 3 :: Double
> y
3.0
> :type y
y :: Double
```

Вывод типа в арифметическом выражении:

```haskell
> let z = y + 17
> :type z
z :: Double
```

Числа с точкой принадлежат к другому типу, не к `Num`:

```haskell
> :type 3.5
3.5 :: Fractional a => a
```

К Fractional относятся Double и Float.

### [Шаг 1.4.4](https://stepik.org/lesson/8412/step/4?unit=1551)

Какие из следующих выражений типизированы верно, то есть не приводят к ошибкам типа?

- [-] (3.0 :: Integer) + (5 :: Integer)
- [+] (3 :: Integer) + (5 :: Integer)
- [-] (3 :: Int) + (5 :: Integer)
- [+] (3.2 :: Double) + (5 :: Double)
- [-] (3 :: Double) + (5 :: Float)

### [Шаг 1.4.5](https://stepik.org/lesson/8412/step/5?unit=1551)

Для описания типов функций существует бинарный инфкисный правоассоциативный оператор `->`.

```haskell
> not False
True

> :t not
not :: Bool -> Bool

(&&) False True
False

>:t (&&)
(&&) :: Bool -> Bool -> Bool
```

Количество аргументов равно количеству стрелочек. 

### [Шаг 1.4.6](https://stepik.org/lesson/8412/step/6?unit=1551)

Вспомним функцию `discount`, которая возвращала итоговую сумму покупки с возможной скидкой. В качестве параметров ей передавались сумма без скидки `sum`, процент скидки `proc`, причем скидка начислялась, если переданная сумма превышает порог `limit`. Все эти параметры, как и возвращаемое значение, можно хранить в типе `Double`. (Здесь следует отметить, что в реальных финансовых приложениях использовать тип с плавающей точкой для хранения подобной информации не рекомендуется.) Тип функции можно задать в файле исходного кода вместе с ее определением:

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

Отметим, что объявление типа необязательно, хотя часто рекомендуется в качестве документации. Его обычно располагают перед определением функции, хотя это объявление верхнего уровня можно расположить в любом месте файла с исходным кодом.

Запишите тип функции `standardDiscount`, определенной как частичное применение функции `discount`:

```
standardDiscount :: ???
standardDiscount = discount 1000 5 
```

#### Решение 1.4.6

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

standardDiscount :: Double -> Double 
standardDiscount = discount 1000 5
```

### [Шаг 1.4.7](https://stepik.org/lesson/8412/step/7?unit=1551)

Деректива `import Module Name` должна располагаться в самом начале после заголовка `module`.

### Шаг 1.4.8

Воспользовавшись справочной системой Hoogle, найдите имя функции типа `Char -> Char`, переводящей символ в нижний регистр.

#### Решение 1.4.8

`toLower`

### [Шаг 1.4.9](https://stepik.org/lesson/8412/step/9?unit=1551)

Реализуйте функцию `twoDigits2Int`, которая принимает два символа и возвращает число, составленное из этих символов, если оба символа числовые, и 100 в противном случае. (Первый символ рассматривается как количество десятков, второй — единиц.)

```haskell
GHCi> twoDigits2Int '4' '2'
42
```

#### Решение 1.4.9

```haskell
import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int a b =
  if isDigit a && isDigit b
  then digitToInt a * 10 + digitToInt b
  else 100
```

### [Шаг 1.4.10](https://stepik.org/lesson/8412/step/10?unit=1551)

Кортеж -- упорядоченный набор элементов фиксированной длины, типы элементов могут быть произвольными.

```haskell
> (2, True)
(2,True)

> (2, True, 'c')
(2,True,'c')
```

Двухэлементных кортежей существуют две полезные функции: `fst`(первйы элемент) и `snd`(второй элемент)

```haskell
> fst (2, True)
2
> snd (2, True)
True
```

Типы в кортежах

```haskell
> :t ('x', True)
('x',True) :: (Char, Bool)

> :t ('x', True, 's')
('x',True, 's') :: (Char, Bool, Char)
```

Кортежа единичной длины в Haskell нет, т.е. `(3)` это не просто число 3. 

Пустой кортеж `()` и его тип

```haskell
> :t ()
() :: ()
```

### [Шаг 1.4.11](https://stepik.org/lesson/8412/step/11?unit=1551)

Будем задавать точки на плоскости парами типа `(Double, Double)`. Реализуйте функцию `dist`, которая возвращает расстояние между двумя точками, передаваемыми ей в качестве аргументов.

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = ???
```

#### Решение 1.4.11

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = sqrt $ (fst p1 - fst p2) ^ 2 + (snd p1 - snd p2) ^ 2
```

### [Шаг 1.4.12](https://stepik.org/lesson/8412/step/12?unit=1551)

Списки гомогенны относительно типов, т.е. все элементы списка должны иметь один тип. Длина списка не фиксирована. 

```haskell
> [1, 2, 3]
[1,2,3]

> [False, True]
[False,True]
```

Из-за того, что списки гомогенны их тип не зависит от их длинны.

```haskell
> :t [False, True]
[False,True] :: [Bool]
```

Для списков типа Char существует специальный синтаксис:

```haskell
> ['H', 'i']
"Hi"

> :t ['H', 'i']
['H','i'] :: [char]

> :t "Hi"
['H','i'] :: [char]

> "Hi" :: String
"Hi"
```

### [Шаг 1.4.13](https://stepik.org/lesson/8412/step/13?unit=1551)

Оператор добавления в голову списка `:`

```haskell
str = 'H' : "ello"

> str
"Hello"
```

Оператор конкатенации двух списков одного и того же типа `++`

```haskell
> str ++ " world"
"Hello world"
```

### [Шаг 1.4.14](https://stepik.org/lesson/8412/step/14?unit=1551)

Операторы `(:)` и `(++)` имеют одинаковую ассоциативность и приоритет. Укажите их. (Воспользуйтесь командой интерпретатора `GHCi :info`).

- infix 5
- infixl 6
- infixl 5
- infixr 6
- [+] infixr 5
- infix 6

### [Шаг 1.4.15](https://stepik.org/lesson/8412/step/15?unit=1551)

Не используя GHCi, выберите выражения, проходящие проверку типов.

- [+] `1 : [2,3] ++ [4,5,6]`
- [+] `[1,2] ++ 3 : [4,5,6]`
- [+] `(:) 1 ((++) [2,3] [4,5,6])`
- [-] `[1,2] ++ [3,4,5] : 6`
  - Нужно внести некоторые изменения в структуру одного из списков `[1,2] ++ 3 : [4,5,6]` или `[1,2] ++ [3,4,5] ++ [6]`
- [-] `[1,2] : 3 ++ [4,5,6]`
  - Нужно внести некоторые изменения в структуру одного из списков `1 : [2,3] ++ [4,5,6]`
- [+] `[1,2] ++ (:) 3 [4,5,6]` --> `[1,2,3,4,5,6]`
- [-] `(++) [1,2] 3 : [4,5,6]`
  - Не хватает скобок `(++) [1,2] (3 : [4,5,6])` или `(++) [1,2] $ 3 : [4,5,6]`
- [-] `(:) 1 (++) [2,3] [4,5,6]`
  - Не хватает скобок `(:) 1 ((++) [2,3] [4,5,6])` или `(:) 1 $ (++) [2,3] [4,5,6]`

---

Все комбинации сводятся к `[1,2,3,4,5,6]`. Все проблемы из-за того, что оператор `:` правоассоциативен или то, что оператор `++` требует списки с обеих сторон.

## Урок 1.5 Рекурсия

### [Шаг 1.5.2](https://stepik.org/lesson/8413/step/2?unit=1552)

Для организации повторяющихся вычислений в функциональных языках используется рекурсия вместо циклов.

Пример рекурсивной функции:

```haskell
factorial n = if n == 0 then 1 else n * factorial (n - 1)
```

Требования к рекурсивной функции:
- Наличие терминирующего условия.
  - В примере выше `if n == 0 then 1`
- Наличие в правой части вызова функции на аргументах отличных от формальных параметров исходной функции.
  - В примере выше `factorial (n - 1)`

В Haskell вычисления происходят по принципу подстановки, т.е. в месте вызова функции осуществляется подстановка тела функции с заменой формального параметра на фактический.  

Демонстрация принципа подстановки на примере вычисления `factorial 2`:
```
factorial 2
  ~> if 2 == 0 then 1 else 2 * factorial 1
  ~> 2 * factorial 1
  ~> 2 * (if 1 == 0 then 1 else 1 * factorial 0)
  ~> 2 * 1 * factorial 0
  ~> 2 * factorial 0
  ~> 2 * (if 0 == 0 then 1 else 0 * factorial (-1))
  ~> 2 * 1
  ~> 2
```

### [Шаг 1.5.3](https://stepik.org/lesson/8413/step/3?unit=1552)

Pattern Matching или сопоставление с образцом.

Определение `factorial`, но с использованием Pattern Matching:
```haskell
factorial' 0 = 1
factorial' n = n * factorial' (n - 1)
```

### [Шаг 1.5.4](https://stepik.org/lesson/8413/step/4?unit=1552)

Определите функцию, вычисляющую двойной факториал, то есть произведение натуральных чисел, 
не превосходящих заданного числа и имеющих ту же четность. Например: $$7!!=7⋅5⋅3⋅1$$, $$8!!=8⋅6⋅4⋅2$$. 
Предполагается, что аргумент функции может принимать только неотрицательные значения.

#### Решение 1.5.4

```haskell
doubleFact :: Integer -> Integer
doubleFact n = if n <= 0 then 1 else n * doubleFact (n - 2)
```

### [Шаг 1.5.5](https://stepik.org/lesson/8413/step/5?unit=1552)

- `error "TEXT"` -- выводит в диагностический поток строку "TEXT"
- `undefined` -- прерывает исполнение программы и выбрасывает в поток стандартное сообщение об ошибке.

Исправленная версия функции `factorial`, выбрасывающая ошибку в случае передачи отрицательного аргумента:
```haskell
factorial'' 0 = 1
factorial'' n = if n < 0 then error "arg must be >= 0" else n * factorial'' (n - 1)
```

С точки зрения статической семантики языка Haskell не завершающаяся рекурсия и прерывание программы из-за ошибки эквивалентны. Считается, что в этом случае возвращаемым значение является специальный символ $\bot$(читается как Up Tack, выглядит как перевёрнутая буква T), оно является элементом любого типа. 

В Haskell `undefined` используется для маркирования ещё не написанных частей программы, т.к. проверка типов гарантированно пройдёт.

### [Шаг 1.5.6](https://stepik.org/lesson/8413/step/6?unit=1552)

Guard Expressions или Охранные выражения.

Функция `factorial`, но переписанная при помощи охранных выражений:

```haskell
factorial''' 0 = 1
factorial''' n | n < 0 = error "arg must be >= 0"
               | n > 0 = n * factorial''' (n - 1)
```

Функция `factorial`, но окончательно переписанная при помощи охранных выражений:

```haskell
factorial4 :: Integer -> Integer
factorial4 n | n == 0 = 1
             | n > 0 = n * factorial4 (n - 1)
             | otherwise = error "arg must be >= 0"
```

### [Шаг 1.5.7](https://stepik.org/lesson/8413/step/7?unit=1552)

В последнем примере предыдущего шага в охранном выражении использовался идентификатор `otherwise`. Это не ключевое слово, а константа, определенная для удобства в стандартной библиотеке:
```
otherwise = ?
```
Как вы думаете, какова правая часть её определения?

#### Решение 1.5.7

- `:t otherwise` выводит тип `otherwise :: Bool`
- `otherwise` должен обязательно сработать, т.е. правая часть равна `True`

### [Шаг 1.5.8](https://stepik.org/lesson/8413/step/8?unit=1552)

Последовательность чисел Фибоначчи 0, 1, 1, 2, 3, 5, 8, 13, 21,... легко определить рекурсивно, задав два первых терминирующих значения и определив любое последующее как сумму двух непосредственно предыдущих: $F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}$.

На Haskell данное определение задаётся следующей функцией:

```haskell
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
```

Эта функция определена лишь для неотрицательных чисел. Однако, из данного выше определения можно вывести формулу для вычисления чисел Фибоначчи при отрицательных индексах, при этом последовательность будет следующей: $F_{-1} = 1, F_{-2} = -1, ..., F_{-10} = -55$.

Измените определение функции `fibonacci` так, чтобы она была определена для всех целых чисел и порождала при отрицательных аргументах указанную последовательность.﻿

#### Решение 1.5.8

```haskell
fibonacci :: Integer -> Integer
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n | n > 0 = fibonacci (n - 1) + fibonacci (n - 2)
            | n < 0 = fibonacci (n + 2) - fibonacci (n + 1)
```

### [Шаг 1.5.9](https://stepik.org/lesson/8413/step/9?unit=1552)

Пример реализации функции `factorial` на языке C:
```c
long factorial (int n) {
  long acc = 1;
  while (n > 1) {
    acc *= n--;
  }
  return acc;
}
```

Реализация идеи с аккумулятором
```haskell
factorial5 n | n >= 0 = helper 1 n
             | otherwise = error "arg must be >= 0"

helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)
```

### [Шаг 1.5.10](https://stepik.org/lesson/8413/step/10?unit=1552)

Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна - количество вызовов функции растет экспоненциально с ростом значения аргумента. GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду `:set +s`:

```haskell
GHCi> :set +s
GHCi> fibonacci 30
832040
(8.36 secs, 298293400 bytes)
```

С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

#### Решение 1.5.10

```haskell
fibonacci :: Integer -> Integer
fibonacci n = fibhelper 0 1 n
fibhelper curr prev n | n == 0 = curr
                      | n > 0  = fibhelper (curr + prev) curr (n - 1)
                      | n < 0  = fibhelper prev (curr - prev) (n + 1)
```

## Урок 1.6 Локальные связывания и правила отступов 

### [Шаг 1.6.2](https://stepik.org/lesson/8414/step/2?unit=1553)

В Haskell отступы играют содержательную роль, они участвуют в создании так называемого двумерного синтаксиса. Отступы измеряются в символах пробела, табуляция(\t) равна 8 пробелам вне зависимости от настроек редактора. Суть: увеличение отступов безопасно, а уменьшение может привести к проблемам. 

```
roots :: Double -> Double -> Double
          -> (Double, Double)
roots a b c =
  (
    (- b - sqrt (b ^ 2 - 4 * a * c)) / (2 * a)
  ,
    (- b + sqrt (b ^ 2 - 4 * a * c)) / (2 * a)
  )
```

C 0-левого отступа начинаются глобальные объявления.

### [Шаг 1.6.3](https://stepik.org/lesson/8414/step/3?unit=1553)

Синтаксис выражения `let...in` для локального связывания переменных.

Порядок связывания порядок не важен. Объявления можно заключать в фигурные скобки и разделяться `;`, но более удобен синтаксис с отступами(локальные связывания должны иметь один и тот же отступ). 

```haskell
roots' :: Double -> Double -> Double -> (Double, Double)
roots' a b c =
  let d = sqrt (b ^ 2 - 4 * a * c) in
  ((- b - d) / (2 * a),(- b + d) / (2 * a))
```

```haskell
roots'' :: Double -> Double -> Double -> (Double, Double)
roots'' a b c =
  let d = {sqrt (b ^ 2 - 4 * a * c); x1 = (- b - d) / (2 * a); x2 = (- b + d) / (2 * a)}
  in (x1, x2)
```

```haskell
roots''' :: Double -> Double -> Double -> (Double, Double)
roots''' a b c =
  let
    x1 = (- b - d) / aTwice
    x2 = (- b + d) / aTwice
    d = sqrt $ b ^ 2 - 4 * a * c
    aTwice = 2 * a
  in (x1, x2)
```

### [Шаг 1.6.4](https://stepik.org/lesson/8414/step/4?unit=1553)

Не используя GHCi, определите строку, которая является значением выражения `(let x = 'w' in [x,'o',x]) ++ "!"`.

#### Решение 1.6.4

`wow!`

### [Шаг 1.6.5](https://stepik.org/lesson/8414/step/5?unit=1553)

С помощью выражения `let...in` можно не только определять локальные связывания, но и локальные функции. 

Переписанная версия реализации `factorial` с аккумулятором дабы избавиться от засорения глобального пространства имён функцией `helper`:

Было:
```haskell
factorial5 n | n >= 0 = helper 1 n
             | otherwise = error "arg must be >= 0"

helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)
```

Стало:
```haskell
factorial6 n
  | n >= 0 = let
      helper acc 0 = acc
      helper acc n = helper (acc * n) (n - 1)
    in helper 1 n
  | otherwise = error "arg must be >= 0"
```

Возможно не только локальное связывание функций, но и локальное связывание образцов. 
```haskell
rootsDiff a b c = let
  (x1, x2) = roots a b c
  in x2 - x1
```

### [Шаг 1.6.6](https://stepik.org/lesson/8414/step/6?unit=1553)

Реализуйте функцию `seqA`, находящую элементы следующей рекуррентной последовательности

$$a_0 = 1; a_1 = 2; a_2 = 3; a_{k + 3} = a_{k + 2} + a_{k + 1} − 2a_k$$.

Попытайтесь найти эффективное решение.
```haskell
GHCi> seqA 301
1276538859311178639666612897162414
```

#### Решение 1.6.6

- Последовательность определена при $k >= 3$ и $k \in N$.
- Чтобы получить формулу для расчёта $k$-ого элемента нужно сделать замену $t = k + 3$(после сделать ещё одну замену $$t = k$$), которая приведёт к $$a_{k} = a_{k - 1} + a_{k - 2} − 2a_{k - 3}$$

```haskell
seqA :: Integer -> Integer
seqA n | n >= 3 = let
                    f a b c 0 = a
                    f a b c 1 = b
                    f a b c 2 = c
                    f a b c k = f b c (c + b - 2 * a) (k - 1)
                  in f 1 2 3 n
       | otherwise = error "k must be >= 0"
```

### [Шаг 1.6.7](https://stepik.org/lesson/8414/step/7?unit=1553)

Помимо конструкции `let...in` есть ещё `where`, но между ними есть отличие `let...in` является выражением, а `where` может использоваться только в определении функции и только в качестве тела этой самой функции.

Локальное связывание с помощью `where`:
```haskell
roots'''' :: Double -> Double -> Double -> (Double, Double)
roots'''' a b c = (x1, x2) where
  d = sqrt (b ^ 2 - 4 * a * c)
  x1 = (- b - d) / aTwice
  x2 = (- b + d) / aTwice
  aTwice = 2 * a
```

Локальное связывание с помощью `let...in`:
```haskell
roots''' :: Double -> Double -> Double -> (Double, Double)
roots''' a b c =
  let
    x1 = (- b - d) / aTwice
    x2 = (- b + d) / aTwice
    d = sqrt $ b ^ 2 - 4 * a * c
    aTwice = 2 * a
  in (x1, x2)
```

Различие между `let...in` и `where` в контексте:

TODO Разобрать подробнее!

```haskell
factorial7 n
  | n >= 0 = helper 1 n
  | otherwise = error "Unexpected a negative argument!"
  where
    helper acc 0 = acc
    helper acc n = helper (acc * n) (n - 1)
```

### [Шаг 1.6.8](https://stepik.org/lesson/8414/step/8?unit=1553)

Реализуйте функцию, находящую сумму и количество цифр десятичной записи заданного целого числа.
```haskell
sum'n'count :: Integer -> (Integer, Integer)
sum'n'count x = undefined
```

```haskell
GHCi> sum'n'count (-39)
(12,2)
```

#### Решение 1.6.8

```haskell
sum'n'count :: Integer -> (Integer, Integer)
sum'n'count 0 = (0, 1)
sum'n'count x = f 0 0 (abs x) where
                f sum count 0 = (sum, count)
                f sum count x = f (sum + x `mod` 10) (count + 1) (x `div` 10)
```

### [Шаг 1.6.9](https://stepik.org/lesson/8414/step/9?unit=1553)

Реализуйте функцию, находящую значение определённого интеграла от заданной функции $$f$$ на заданном интервале 
[a,b] методом трапеций. (Используйте равномерную сетку; достаточно 1000 элементарных отрезков.)

```haskell
integration :: (Double -> Double) -> Double -> Double -> Double
integration f a b = undefined
```

```haskell
GHCi> integration sin pi 0
-2.0
```

Результат может отличаться от -2.0, но не более чем на 1e-4.

#### Решение 1.6.9

```haskell
integration :: (Double -> Double) -> Double -> Double -> Double
integration f a b = trapezoidalRule f a b 1000 where
                    trapezoidalRule f a b 0 = 0
                    trapezoidalRule f a b n = h * (f (a) + f (a + h)) / 2 + 
                                              trapezoidalRule f (a + h) b (n - 1) where h = (b - a) / n
```
