# Модуль 1 Введение

## Урок 1.1 Установка и настройка среды

Критерии сдачи курса: для обычного сертификата достаточно набрать 140 баллов, для сертификата с отличием – 200 баллов.

### [Шаг 1.1.2](https://stepik.org/lesson/8119/step/2?unit=1375)

- Haskell Platform
  - Компилятор GHC == Glasgow Haskell Compiler
  - REPL интерпретатор GHCi == Glasgow Haskell Compiler interpreter
- Исходный код имеет расширение `.hs`
- Табуляция Tab(\t) равна 8 пробелов независимо от настроек редактора

### [Шаг 1.1.3](https://stepik.org/lesson/8119/step/3?unit=1375)

### [Шаг 1.1.4](https://stepik.org/lesson/8119/step/4?unit=1375)

- На момент разработки курса последней версией была Haskell Platform 2014.2.0.0
- Версия компилятора GHC 7.8.2 используется для проверки домашних заданий

На данный момент(с 2022 года) от Haskell Platform отказались.

### [Шаг 1.1.5](https://stepik.org/lesson/8119/step/5?unit=1375)

- Для запуска интерпретатора в командной строке `ghci`
- Чтобы поменять приглашение командной строке нужно набрать `:set prompt "GHCi>"`. 
  - ! Переопределение скрывает имя загруженного модуля

### [Шаг 1.1.6](https://stepik.org/lesson/8119/step/6?unit=1375)

Запустите ваш текстовой редактор и создайте файл `Hello.hs`, содержащий следующую строку кода:

```haskell
main = putStrLn "Hello, world!"
```

Вызовите теперь с помощью средств вашей ОС интерпретатор GHCi c параметром — именем файла исходного кода:

```haskell
ghci Hello.hs
```

(Файл должен располагаться в том же каталоге, откуда происходит вызов интерпретатора.) Проверьте, что загрузка модуля прошла успешно, вызвав в интерпретаторе определенную вами функцию `main`:

```haskell
GHCi> main
Hello, world!
```

Какое приглашение на самом деле выдает командная строка интерпретатора (в предыдущем примере интерпретатор выдал приглашение `GHCi> `)?

#### Решение 1.1.6

```haskell
*Main>
```

### [Шаг 1.1.7](https://stepik.org/lesson/8119/step/7?unit=1375)

- Чтобы в уже запущенный интерпретатор подгрузить модуль нужно использовать `:load moduleName` или `:l moduleName`, сократив до первой буквы.
- Чтобы перезагрузить модуль после внесения изменений в него нужно использовать `:reload moduleName`

## Урок 1.2 Функции

### [Шаг 1.2.2](https://stepik.org/lesson/7859/step/2?unit=1351)

В языке Haskell программа представляет из себя некоторое выражение, а выполнение программы это последовательные редукции этого выражения до состояния, когда никаких редукций совершить нельзя. 

Пример последовательности редукций:

```
(5 + 4 * 3) ^ 2
    Первая редукция ~> (5 + 12) ^ 2
    Вторая редукция ~> 17 ^ 2
    Третья и окончательная редукция ~> 289
```

`~>` обозначение шага редукции

### [Шаг 1.2.3](https://stepik.org/lesson/7859/step/3?unit=1351)

Синтаксис двух последовательных обозначает применение одного аргумента к другому. 

```haskell
-- Применение foo к bar

Prelude> foo bar
```

Скобки используются для группировки аргументов 

```haskell
{-
Вычисление arccos (cos pi) == pi
Сначала cos pi, а потом уже arccos от результата.
-}

Prelude> acos (cos pi)
```

Вызов функций двух аргументов `f x y`, где `f` функция, а `x` и `y` её аргументы. `max 5 42` вернёт `42`

### [Шаг 1.2.4](https://stepik.org/lesson/7859/step/4?unit=1351)

`max 5 42` вернёт `42` можно записать как `(max 5) 42` и тоже вернёт `42` -- операция применения функции ассоциативна влево. `(max 5)` называется частичным применением функции, результат работы выражения функция одного аргумента и может быть применена там, где требуется функция одного аргумента. 

В общем виде частичное применение функций можно сформулировать как применение функции от n переменных, но с точки зрения функции от одной переменной, но применённой n раз. Каждое применение такой функции будет возвращать функцию от n - 1 переменной.

### [Шаг 1.2.5](https://stepik.org/lesson/7859/step/5?unit=1351)

В стандартной библиотеке Haskell есть функция вычисления логарифма по произвольному основанию `logBase`. Это функция двух переменных, которой требуется передать основание логарифма и аргумент, на котором логарифм будет вычислен. Какие из следующих вызовов обеспечат вычисление логарифма по основанию 2 от 8?

- [+] (logBase 2) 8
- [-] logBase (2 8)
- [-] logBase (2, 8)
- [+] logBase 2 8
- [-] (logBase, 2, 8)

### [Шаг 1.2.6](https://stepik.org/lesson/7859/step/6?unit=1351)

Чтобы определить функцию нужно: задать её имя, указать параметры, поставить знак равенства и после знака равенства реализовать тело функции. Пример функции:

```haskell
sumSquares x y = x ^ 2 + y ^ 2
```

Регистр важен. Имя функции и параметры должны начинаться с символа в нижнем регистре. Символы в вернхнем регистре служат для определения типов данных.

В Haskell возможны имена включащие в себя `'`

Чтобы определить функцию в GHCi нужно использовать ключевое слово `let` перед именем функции.

### [Шаг 1.2.7](https://stepik.org/lesson/7859/step/7?unit=1351)

Реализуйте функцию трех аргументов `lenVec3`, которая вычисляет длину трехмерного вектора. Аргументы функции задают декартовы координаты конца вектора, его начало подразумевается находящимся в начале координат. Для извлечения квадратного корня воспользуйтесь функцией `sqrt`, определенной в стандартной библиотеке.

```haskell
GHCi> lenVec3 2 3 6
7.0
```

#### Решение 1.2.7

```haskell
lenVec3 x y z =  sqrt (x ^ 2 + y ^ 2 + z ^ 2)
```

### [Шаг 1.2.8](https://stepik.org/lesson/7859/step/8?unit=1351)

Важная отличительна черта функциональных языков это чистые функции. Функции чистые, т.е. не имеют внешних эффектов и определяются только её аргументами.

Функция, которая не принимает аргументов, это константа или константная функция. 

### [Шаг 1.2.9](https://stepik.org/lesson/7859/step/9?unit=1351)

Пример условного выражения `f x = if x > 0 then 1 else (-1)`

Отрицательные числа следует заключать в скобки

В Haskell обе ветви условного выражения должны присутствовать. В ветвях должны быть выражения одного и того же типа. 

### [Шаг 1.2.10](https://stepik.org/lesson/7859/step/10?unit=1351)

Напишите реализацию функции `sign`, которая возвращает 1, если ей передано положительное число, (-1), если отрицательное, и 0 в случае, когда передан 0.

```haskell
GHCi> sign (-100)
-1
```

#### Решение 1.2.10

```haskell
sign x = if x > 0 then 1 else if x == 0 then 0 else (-1)
```

### [Шаг 1.2.11](https://stepik.org/lesson/7859/step/11?unit=1351)

Механизм определения функций с помощью частичного применения

```haskell
max5 x = max 5 x
--- Эквивалентен
max5` = max 5 
--- max5' это частично применённая функция max
```

Подобный стиль называется бесточечным.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

В Haskell часто специально проектируют функции, чтобы их было проще применять частично. В функции `discount` параметры `proc` и `limit` меняются крайне редко, а вот `sum` постоянно.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
--- Функция определения стандартной скидки.
standardDiscount = discount 1000 5
```

Функция `standardDiscount` определена как частичная, т.к. параметр `sum` опущен. Теперь Функция `standardDiscount` может быть вызвана с одним параметром. 

### [Шаг 1.2.12](https://stepik.org/lesson/7859/step/12?unit=1351)

Предположим, мы разрабатываем на Haskell интерфейс системы перевода для естественных языков. Он должен содержать функцию `translate` с параметрами `text`, `languageFrom` и `languageTo`. Расположите параметры в таком порядке, чтобы было удобно реализовывать следующие функции: `translateFromSpanishToRussian`, `translateFromEnglishToRussian` и `translateToRussian`.

- [+] translate languageTo languageFrom text
- translate text languageFrom languageTo
- translate languageTo text languageFrom
- translate languageFrom languageTo text
- translate text languageTo languageFrom
- translate languageFrom text languageTo

- Поставить параметр `languageTo` первым, т.к. все три функции переводят на русский язык.
- Поставить параметр `languageFrom` вторым, т.к. `FromSpanish`, `FromEnglish` и в последнем язык случае с какого языка будет происходить перевод вообще явно не определён.
- Поставить параметр `text` в конце, т.к. он постоянно меняется. Частичное применение. 

## Урок 1.3 Операторы

## Урок 1.4 Базовые типы

## Урок 1.5 Рекурсия

## Урок 1.6 Локальные связывания и правила отступов 
