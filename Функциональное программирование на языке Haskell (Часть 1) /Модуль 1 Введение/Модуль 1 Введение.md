# Модуль 1 Введение

## Урок 1.1 Установка и настройка среды

Критерии сдачи курса: для обычного сертификата достаточно набрать 140 баллов, для сертификата с отличием – 200 баллов.

### [Шаг 1.1.2](https://stepik.org/lesson/8119/step/2?unit=1375)

- Haskell Platform
  - Компилятор GHC == Glasgow Haskell Compiler
  - REPL интерпретатор GHCi == Glasgow Haskell Compiler interpreter
- Исходный код имеет расширение `.hs`
- Табуляция Tab(\t) равна 8 пробелов независимо от настроек редактора

### [Шаг 1.1.3](https://stepik.org/lesson/8119/step/3?unit=1375)

- Язык Haskell — чистый функциональный язык программирования с «ленивой» семантикой исполнения и полиморфной статической типизацией.
- Язык назван в честь американского логика и математика Хаскелла Брукса Карри.
- [Официальный сайт](https://www.haskell.org/)
- Справку по функциям стандартной библиотеки можно получить с помощью [Hoogle](https://www.haskell.org/hoogle/)

### [Шаг 1.1.4](https://stepik.org/lesson/8119/step/4?unit=1375)

- На момент разработки курса последней версией была Haskell Platform 2014.2.0.0
- Версия компилятора GHC 7.8.2 используется для проверки домашних заданий

На данный момент(с 2022 года) от Haskell Platform отказались.

### [Шаг 1.1.5](https://stepik.org/lesson/8119/step/5?unit=1375)

- Для запуска интерпретатора в командной строке `ghci`
- Чтобы поменять приглашение командной строке нужно набрать `:set prompt "GHCi>"`. 
  - ! Переопределение скрывает имя загруженного модуля

### [Шаг 1.1.6](https://stepik.org/lesson/8119/step/6?unit=1375)

Запустите ваш текстовой редактор и создайте файл `Hello.hs`, содержащий следующую строку кода:

```haskell
main = putStrLn "Hello, world!"
```

Вызовите теперь с помощью средств вашей ОС интерпретатор GHCi c параметром — именем файла исходного кода:

```haskell
ghci Hello.hs
```

(Файл должен располагаться в том же каталоге, откуда происходит вызов интерпретатора.) Проверьте, что загрузка модуля прошла успешно, вызвав в интерпретаторе определенную вами функцию `main`:

```haskell
GHCi> main
Hello, world!
```

Какое приглашение на самом деле выдает командная строка интерпретатора (в предыдущем примере интерпретатор выдал приглашение `GHCi> `)?

#### Решение 1.1.6

```haskell
*Main>
```

### [Шаг 1.1.7](https://stepik.org/lesson/8119/step/7?unit=1375)

- Чтобы в уже запущенный интерпретатор подгрузить модуль нужно использовать `:load moduleName` или `:l moduleName`, сократив до первой буквы.
- Чтобы перезагрузить модуль после внесения изменений в него нужно использовать `:reload moduleName`

## Урок 1.2 Функции

### [Шаг 1.2.2](https://stepik.org/lesson/7859/step/2?unit=1351)

В языке Haskell программа представляет из себя некоторое выражение, а выполнение программы это последовательные редукции этого выражения до состояния, когда никаких редукций совершить нельзя. 

Пример последовательности редукций:

```
(5 + 4 * 3) ^ 2
    Первая редукция ~> (5 + 12) ^ 2
    Вторая редукция ~> 17 ^ 2
    Третья и окончательная редукция ~> 289
```

`~>` обозначение шага редукции

### [Шаг 1.2.3](https://stepik.org/lesson/7859/step/3?unit=1351)

Следующий синтаксис двух последовательных идентификаторов обозначает применение `foo bar`, т.е. `foo` применяется к `bar`.

Скобки используются для группировки аргументов 

```haskell
{-
Вычисление arccos (cos pi) == pi
Сначала cos pi, а потом уже arccos от результата.
-}

> acos (cos pi)
3.141592653589793
```

Вызов функций двух аргументов `f x y`, где `f` функция, а `x` и `y` её аргументы. `max 5 42` вернёт `42`

### [Шаг 1.2.4](https://stepik.org/lesson/7859/step/4?unit=1351)

`max 5 42` вернёт `42` можно записать как `(max 5) 42` и тоже вернёт `42` -- операция применения функции ассоциативна влево. `(max 5)` называется частичным применением функции, результат работы выражения функция одного аргумента и может быть применена там, где требуется функция одного аргумента. 

В общем виде частичное применение функций можно сформулировать как применение функции от n переменных, но с точки зрения функции от одной переменной, но применённой n раз. Каждое применение такой функции будет возвращать функцию от n - 1 переменной.

### [Шаг 1.2.5](https://stepik.org/lesson/7859/step/5?unit=1351)

В стандартной библиотеке Haskell есть функция вычисления логарифма по произвольному основанию `logBase`. Это функция двух переменных, которой требуется передать основание логарифма и аргумент, на котором логарифм будет вычислен. Какие из следующих вызовов обеспечат вычисление логарифма по основанию 2 от 8?

- [+] (logBase 2) 8
- [-] logBase (2 8)
- [-] logBase (2, 8)
- [+] logBase 2 8
- [-] (logBase, 2, 8)

### [Шаг 1.2.6](https://stepik.org/lesson/7859/step/6?unit=1351)

Чтобы определить функцию нужно: задать её имя, указать параметры, поставить знак равенства и после знака равенства реализовать тело функции. Пример функции:

```haskell
sumSquares x y = x ^ 2 + y ^ 2
```

Регистр важен. Имя функции и параметры должны начинаться с символа в нижнем регистре. Символы в вернхнем регистре служат для определения типов данных.

В Haskell возможны имена включащие в себя `'`

Чтобы определить функцию в GHCi нужно использовать ключевое слово `let` перед именем функции.

### [Шаг 1.2.7](https://stepik.org/lesson/7859/step/7?unit=1351)

Реализуйте функцию трех аргументов `lenVec3`, которая вычисляет длину трехмерного вектора. Аргументы функции задают декартовы координаты конца вектора, его начало подразумевается находящимся в начале координат. Для извлечения квадратного корня воспользуйтесь функцией `sqrt`, определенной в стандартной библиотеке.

```haskell
GHCi> lenVec3 2 3 6
7.0
```

#### Решение 1.2.7

```haskell
lenVec3 x y z =  sqrt (x ^ 2 + y ^ 2 + z ^ 2)
```

### [Шаг 1.2.8](https://stepik.org/lesson/7859/step/8?unit=1351)

Важная отличительна черта функциональных языков это чистые функции. Функции чистые, т.е. не имеют внешних эффектов и определяются только её аргументами.

Функция, которая не принимает аргументов, это константа или константная функция. 

### [Шаг 1.2.9](https://stepik.org/lesson/7859/step/9?unit=1351)

Пример условного выражения `f x = if x > 0 then 1 else (-1)`

Отрицательные числа следует заключать в скобки

В Haskell обе ветви условного выражения должны присутствовать. В ветвях должны быть выражения одного и того же типа. 

### [Шаг 1.2.10](https://stepik.org/lesson/7859/step/10?unit=1351)

Напишите реализацию функции `sign`, которая возвращает 1, если ей передано положительное число, (-1), если отрицательное, и 0 в случае, когда передан 0.

```haskell
GHCi> sign (-100)
-1
```

#### Решение 1.2.10

```haskell
sign x = if x > 0 then 1 else if x == 0 then 0 else (-1)
```

### [Шаг 1.2.11](https://stepik.org/lesson/7859/step/11?unit=1351)

Механизм определения функций с помощью частичного применения

```haskell
max5 x = max 5 x
--- Эквивалентен
max5` = max 5 
--- max5' это частично применённая функция max
```

Подобный стиль называется бесточечным.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

В Haskell часто специально проектируют функции, чтобы их было проще применять частично. В функции `discount` параметры `proc` и `limit` меняются крайне редко, а вот `sum` постоянно.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
--- Функция определения стандартной скидки.
standardDiscount = discount 1000 5
```

Функция `standardDiscount` определена как частичная, т.к. параметр `sum` опущен. Теперь Функция `standardDiscount` может быть вызвана с одним параметром. 

### [Шаг 1.2.12](https://stepik.org/lesson/7859/step/12?unit=1351)

Предположим, мы разрабатываем на Haskell интерфейс системы перевода для естественных языков. Он должен содержать функцию `translate` с параметрами `text`, `languageFrom` и `languageTo`. Расположите параметры в таком порядке, чтобы было удобно реализовывать следующие функции: `translateFromSpanishToRussian`, `translateFromEnglishToRussian` и `translateToRussian`.

- [+] translate languageTo languageFrom text
- translate text languageFrom languageTo
- translate languageTo text languageFrom
- translate languageFrom languageTo text
- translate text languageTo languageFrom
- translate languageFrom text languageTo

Поставить параметр `languageTo` первым, т.к. все три функции переводят на русский язык.

Поставить параметр `languageFrom` вторым, т.к. `FromSpanish`, `FromEnglish` и в последнем язык случае с какого языка будет происходить перевод вообще явно не определён.

Поставить параметр `text` в конце, т.к. он постоянно меняется. Частичное применение. 

## Урок 1.3 Операторы

### [Шаг 1.3.2](https://stepik.org/lesson/8411/step/2?unit=1550)

Функции вызываются в префиксном стиле, т.е. функция идёт перед своими аргументами, а операторы в инфиксном стиле, т.е. оператор находится между своими аргументами. Это различие можно убрать и начать вызывать операторы в префиксном стиле и функции в инфиксном. Для этого нужно поместить функцию между аргументами и заключить в обратные ковычки, операторы нужно заключить в скобки и поставить перед аргументами. 

```haskell
max 6 7
6 `max` 7
--
6 + 7
(+) 6 7
```

Все операторы в Haskell бинарные, т.е. принимают два аргумента. Кроме унарного префиксного минуса, который служить для создания отрицательных чисел.

### [Шаг 1.3.3](https://stepik.org/lesson/8411/step/3?unit=1550)

Применение функции имеет наивысший приоритет равный 10.

Для установки приоритета и ассоциативность служат следующие ключевые слова:
- `infixl` -- левоассоциативность
- `infixr` -- правоассоциативность
- `infix` -- без указания характера ассоциативности
- затем указывается число от 1 до 10
- и в конце имя оператора

```haskell
-- Пример из стандартной библиотеки 
infixr 8 ^, `logBase`
infixl 7 *, /, `div`, `mod`
infixl 6 +, -
infix 4 ==, /=, >, >=, <, <=
```

По-умолчанию в Haskell принята левоассоциативность и приоритет 9.

### [Шаг 1.3.4](https://stepik.org/lesson/8411/step/4?unit=1550)

Попробуйте вычислить значение выражения `2 ^ 3 ^ 2`, не используя GHCi.

#### Решение 1.3.4

```
2 ^ 3 ^ 2
~> 2 ^ 9
~> 512
```

### [Шаг 1.3.5](https://stepik.org/lesson/8411/step/5?unit=1550)

Попробуйте вычислить значение выражения `(*) 2 ((+) 1 4) ^ 2`, не используя GHCi.

#### Решение 1.3.5

```
(*) 2 ((+) 1 4) ^ 2
~> (*) 2 5 ^ 2
~> 10 ^ 2 = 100
```

### [Шаг 1.3.6](https://stepik.org/lesson/8411/step/6?unit=1550)

В Haskell нет встроенных операторов. 

Список символов, из которых можно составить собственные операторы: `! # $ % & * + . / < = > & @ \ ^ | - ~`

Пример собственного оператора: 

```haskell
infixl 6 *+*

-- В инфиксной нотации или операторном стиле
a *+* b = a ^ 2 + b ^ 2
-- В префиксной нотации или в функциональном стиле
(*+*) a b = a ^ 2 + b ^ 2
```

### [Шаг 1.3.7](https://stepik.org/lesson/8411/step/7?unit=1550)

Используя данное выше определение оператора `(*+*)`:

```haskell
infixl 6 *+*
(*+*) a b = a ^ 2 + b ^ 2
```

попробуйте устно вычислить значение выражения `1 + 3 *+* 2 * 2`.

#### Решение 1.3.7

```
1 + 3 *+* 2 * 2
~> 1 + 3 *+* 4
~> 4 *+* 4 
~> 4 ^ 2 + 4 ^ 2 = 16 + 16 = 32
```

### [Шаг 1.3.8](https://stepik.org/lesson/8411/step/8?unit=1550)

Реализуйте оператор `|-|`, который возвращает модуль разности переданных ему аргументов:

```haskell
GHCi>  5 |-| 7
2
```

#### Решение 1.3.8

```haskell
{-
Реализуйте оператор |-|, который возвращает модуль разности переданных ему аргументов:

GHCi>  5 |-| 7
2
-}
x |-| y = if x - y >= 0 then x - y else y - x
-- x |-| y = abs (x - y)
```

### [Шаг 1.3.9](https://stepik.org/lesson/8411/step/9?unit=1550)

Специальный компактный синтаксис частичного применения оператора к одному из своих аргументов.

```haskell
-- Сечение оператора. Связывание слева.
(2 /) 4
-- Вернёт 0.5 как ожидалось.

-- Сечение оператора. Связывание справа.
(/ 2) 4
-- Вернёт 2.0 как ожидалось.
```

Подобный синтаксис требует обязательного использования круглых скобок. Оператор унарный минус `(-)` является исключением.

### [Шаг 1.3.10](https://stepik.org/lesson/8411/step/10?unit=1550)

Попробуйте вычислить значение выражения `('mod' 14) ((+ 5) 10)`, не используя GHCi. (Функция `mod` возвращает остаток от целочисленного деления первого своего аргумента на второй.)

#### Решение 1.3.10

```
('mod' 14) ((+ 5) 10)
~> ('mod' 14) 15
~> 15 mod 14 = 1
```

### [Шаг 1.3.11](https://stepik.org/lesson/8411/step/11?unit=1550)

Оператор `$`. Его приоритет равен 0 и правоассоциативный. Он используется для избавления от избыточных скобок. 

Записи `sin 0` и `sin $ 0` эквивалетны.

Запись `sin (pi / 2)` можно упростить с помощью оператора `$` и записать как `sin $ pi / 2`.

`f (g x (h y))` == `f $ g x (h y)` == `f $ g x $ h y`

### [Шаг 1.3.12](https://stepik.org/lesson/8411/step/12?unit=1550)

Используя оператор `$`, перепишите выражение `logBase 4 (min 20 (9 + 7))` без скобок. (Разделяйте все токены одним пробелом.)

#### Решение 1.3.12

```haskell
logBase 4 $ min 20 $ 9 + 7
```

## Урок 1.4 Базовые типы

### [Шаг 1.4.2](https://stepik.org/lesson/8412/step/2?unit=1551)

Haskell имеет строгую статическую систему типов это значит, что отсутствуют неявные приведения типов, проверка типов происходит во время компиляции, а не во время исполнения.

В `ghci` можно узнать тип с помощью команды `:type`

```haskell
> :type 'c'
'c' :: Char
> :type '\n'
'\n' :: Char
> :type True
True :: Bool
> :type False
False :: Bool
```

### [Шаг 1.4.3](https://stepik.org/lesson/8412/step/3?unit=1551)

```haskell
> :type 3
3 :: Num a => a
```

Чтобы явно указать тип нужно применить оператора `::`

```haskell
> let x = 3 :: Int
> x
3
> :type x
x :: Int
> let y = 3 :: Double
> y
3.0
> :type y
y :: Double
```

Вывод типа в арифметическом выражении:

```haskell
> let z = y + 17
> :type z
z :: Double
```

Числа с точкой принадлежат к другому типу, не к `Num`:

```haskell
> :type 3.5
3.5 :: Fractional a => a
```

К Fractional относятся Double и Float.

### [Шаг 1.4.4](https://stepik.org/lesson/8412/step/4?unit=1551)

Какие из следующих выражений типизированы верно, то есть не приводят к ошибкам типа?

- [-] (3.0 :: Integer) + (5 :: Integer)
- [+] (3 :: Integer) + (5 :: Integer)
- [-] (3 :: Int) + (5 :: Integer)
- [+] (3.2 :: Double) + (5 :: Double)
- [-] (3 :: Double) + (5 :: Float)

### [Шаг 1.4.5](https://stepik.org/lesson/8412/step/5?unit=1551)

Для описания типов функций существует бинарный инфкисный правоассоциативный оператор `->`.

```haskell
> not False
True

> :t not
not :: Bool -> Bool

(&&) False True
False

>:t (&&)
(&&) :: Bool -> Bool -> Bool
```

Количество аргументов равно количеству стрелочек. 

### [Шаг 1.4.6](https://stepik.org/lesson/8412/step/6?unit=1551)

Вспомним функцию `discount`, которая возвращала итоговую сумму покупки с возможной скидкой. В качестве параметров ей передавались сумма без скидки `sum`, процент скидки `proc`, причем скидка начислялась, если переданная сумма превышает порог `limit`. Все эти параметры, как и возвращаемое значение, можно хранить в типе `Double`. (Здесь следует отметить, что в реальных финансовых приложениях использовать тип с плавающей точкой для хранения подобной информации не рекомендуется.) Тип функции можно задать в файле исходного кода вместе с ее определением:

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

Отметим, что объявление типа необязательно, хотя часто рекомендуется в качестве документации. Его обычно располагают перед определением функции, хотя это объявление верхнего уровня можно расположить в любом месте файла с исходным кодом.

Запишите тип функции `standardDiscount`, определенной как частичное применение функции `discount`:

```
standardDiscount :: ???
standardDiscount = discount 1000 5 
```

#### Решение 1.4.6

```haskell
discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

standardDiscount :: Double -> Double 
standardDiscount = discount 1000 5
```

### [Шаг 1.4.7](https://stepik.org/lesson/8412/step/7?unit=1551)

Деректива `import Module Name` должна располагаться в самом начале после заголовка `module`.

### Шаг 1.4.8

Воспользовавшись справочной системой Hoogle, найдите имя функции типа `Char -> Char`, переводящей символ в нижний регистр.

#### Решение 1.4.8

`toLower`

### [Шаг 1.4.9](https://stepik.org/lesson/8412/step/9?unit=1551)

Реализуйте функцию `twoDigits2Int`, которая принимает два символа и возвращает число, составленное из этих символов, если оба символа числовые, и 100 в противном случае. (Первый символ рассматривается как количество десятков, второй — единиц.)

```haskell
GHCi> twoDigits2Int '4' '2'
42
```

#### Решение 1.4.9

```haskell
import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int a b =
  if isDigit a && isDigit b
  then digitToInt a * 10 + digitToInt b
  else 100
```

### [Шаг 1.4.10](https://stepik.org/lesson/8412/step/10?unit=1551)

Кортеж -- упорядоченный набор элементов фиксированной длины, типы элементов могут быть произвольными.

```haskell
> (2, True)
(2,True)

> (2, True, 'c')
(2,True,'c')
```

Двухэлементных кортежей существуют две полезные функции: `fst`(первйы элемент) и `snd`(второй элемент)

```haskell
> fst (2, True)
2
> snd (2, True)
True
```

Типы в кортежах

```haskell
> :t ('x', True)
('x',True) :: (Char, Bool)

> :t ('x', True, 's')
('x',True, 's') :: (Char, Bool, Char)
```

Кортежа единичной длины в Haskell нет, т.е. `(3)` это не просто число 3. 

Пустой кортеж `()` и его тип

```haskell
> :t ()
() :: ()
```

### [Шаг 1.4.11](https://stepik.org/lesson/8412/step/11?unit=1551)

Будем задавать точки на плоскости парами типа `(Double, Double)`. Реализуйте функцию `dist`, которая возвращает расстояние между двумя точками, передаваемыми ей в качестве аргументов.

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = ???
```

#### Решение 1.4.11

```haskell
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = sqrt $ (fst p1 - fst p2) ^ 2 + (snd p1 - snd p2) ^ 2
```

### [Шаг 1.4.12](https://stepik.org/lesson/8412/step/12?unit=1551)

Списки гомогенны относительно типов, т.е. все элементы списка должны иметь один тип. Длина списка не фиксирована. 

```haskell
> [1, 2, 3]
[1,2,3]

> [False, True]
[False,True]
```

Из-за того, что списки гомогенны их тип не зависит от их длинны.

```haskell
> :t [False, True]
[False,True] :: [Bool]
```

Для списков типа Char существует специальный синтаксис:

```haskell
> ['H', 'i']
"Hi"

> :t ['H', 'i']
['H','i'] :: [char]

> :t "Hi"
['H','i'] :: [char]

> "Hi" :: String
"Hi"
```

### [Шаг 1.4.13](https://stepik.org/lesson/8412/step/13?unit=1551)

Оператор добавления в голову списка `:`

```haskell
str = 'H' : "ello"

> str
"Hello"
```

Оператор конкатенации двух списков одного и того же типа `++`

```haskell
> str ++ " world"
"Hello world"
```

### [Шаг 1.4.14](https://stepik.org/lesson/8412/step/14?unit=1551)

Операторы `(:)` и `(++)` имеют одинаковую ассоциативность и приоритет. Укажите их. (Воспользуйтесь командой интерпретатора `GHCi :info`).

- infix 5
- infixl 6
- infixl 5
- infixr 6
- [+] infixr 5
- infix 6

### [Шаг 1.4.15](https://stepik.org/lesson/8412/step/15?unit=1551)

Не используя GHCi, выберите выражения, проходящие проверку типов.

- [+] `1 : [2,3] ++ [4,5,6]`
- [+] `[1,2] ++ 3 : [4,5,6]`
- [+] `(:) 1 ((++) [2,3] [4,5,6])`
- [-] `[1,2] ++ [3,4,5] : 6`
  - Нужно внести некоторые изменения в структуру одного из списков `[1,2] ++ 3 : [4,5,6]` или `[1,2] ++ [3,4,5] ++ [6]`
- [-] `[1,2] : 3 ++ [4,5,6]`
  - Нужно внести некоторые изменения в структуру одного из списков `1 : [2,3] ++ [4,5,6]`
- [+] `[1,2] ++ (:) 3 [4,5,6]` --> `[1,2,3,4,5,6]`
- [-] `(++) [1,2] 3 : [4,5,6]`
  - Не хватает скобок `(++) [1,2] (3 : [4,5,6])` или `(++) [1,2] $ 3 : [4,5,6]`
- [-] `(:) 1 (++) [2,3] [4,5,6]`
  - Не хватает скобок `(:) 1 ((++) [2,3] [4,5,6])` или `(:) 1 $ (++) [2,3] [4,5,6]`

---

Все комбинации сводятся к `[1,2,3,4,5,6]`. Все проблемы из-за того, что оператор `:` правоассоциативен или то, что оператор `++` требует списки с обеих сторон.

## Урок 1.5 Рекурсия

## Урок 1.6 Локальные связывания и правила отступов 
