# Модуль 1 Введение

## Урок 1.1 Установка и настройка среды

Критерии сдачи курса: для обычного сертификата достаточно набрать 140 баллов, для сертификата с отличием – 200 баллов.

### [Шаг 1.1.2](https://stepik.org/lesson/8119/step/2?unit=1375)

- Haskell Platform
  - Компилятор GHC == Glasgow Haskell Compiler
  - REPL интерпретатор GHCi == Glasgow Haskell Compiler interpreter
- Исходный код имеет расширение `.hs`
- Табуляция Tab(\t) равна 8 пробелов независимо от настроек редактора

### [Шаг 1.1.3](https://stepik.org/lesson/8119/step/3?unit=1375)

- Язык Haskell — чистый функциональный язык программирования с «ленивой» семантикой исполнения и полиморфной статической типизацией.
- Язык назван в честь американского логика и математика Хаскелла Брукса Карри.
- [Официальный сайт](https://www.haskell.org/)
- Справку по функциям стандартной библиотеки можно получить с помощью [Hoogle](https://www.haskell.org/hoogle/)

### [Шаг 1.1.4](https://stepik.org/lesson/8119/step/4?unit=1375)

- На момент разработки курса последней версией была Haskell Platform 2014.2.0.0
- Версия компилятора GHC 7.8.2 используется для проверки домашних заданий

На данный момент(с 2022 года) от Haskell Platform отказались.

### [Шаг 1.1.5](https://stepik.org/lesson/8119/step/5?unit=1375)

- Для запуска интерпретатора в командной строке `ghci`
- Чтобы поменять приглашение командной строке нужно набрать `:set prompt "GHCi>"`. 
  - ! Переопределение скрывает имя загруженного модуля

### [Шаг 1.1.6](https://stepik.org/lesson/8119/step/6?unit=1375)

Запустите ваш текстовой редактор и создайте файл `Hello.hs`, содержащий следующую строку кода:

```haskell
main = putStrLn "Hello, world!"
```

Вызовите теперь с помощью средств вашей ОС интерпретатор GHCi c параметром — именем файла исходного кода:

```haskell
ghci Hello.hs
```

(Файл должен располагаться в том же каталоге, откуда происходит вызов интерпретатора.) Проверьте, что загрузка модуля прошла успешно, вызвав в интерпретаторе определенную вами функцию `main`:

```haskell
GHCi> main
Hello, world!
```

Какое приглашение на самом деле выдает командная строка интерпретатора (в предыдущем примере интерпретатор выдал приглашение `GHCi> `)?

#### Решение 1.1.6

```haskell
*Main>
```

### [Шаг 1.1.7](https://stepik.org/lesson/8119/step/7?unit=1375)

- Чтобы в уже запущенный интерпретатор подгрузить модуль нужно использовать `:load moduleName` или `:l moduleName`, сократив до первой буквы.
- Чтобы перезагрузить модуль после внесения изменений в него нужно использовать `:reload moduleName`

## Урок 1.2 Функции

### [Шаг 1.2.2](https://stepik.org/lesson/7859/step/2?unit=1351)

В языке Haskell программа представляет из себя некоторое выражение, а выполнение программы это последовательные редукции этого выражения до состояния, когда никаких редукций совершить нельзя. 

Пример последовательности редукций:

```
(5 + 4 * 3) ^ 2
    Первая редукция ~> (5 + 12) ^ 2
    Вторая редукция ~> 17 ^ 2
    Третья и окончательная редукция ~> 289
```

`~>` обозначение шага редукции

### [Шаг 1.2.3](https://stepik.org/lesson/7859/step/3?unit=1351)

Синтаксис двух последовательных обозначает применение одного аргумента к другому. 

```haskell
-- Применение foo к bar

Prelude> foo bar
```

Скобки используются для группировки аргументов 

```haskell
{-
Вычисление arccos (cos pi) == pi
Сначала cos pi, а потом уже arccos от результата.
-}

Prelude> acos (cos pi)
```

Вызов функций двух аргументов `f x y`, где `f` функция, а `x` и `y` её аргументы. `max 5 42` вернёт `42`

### [Шаг 1.2.4](https://stepik.org/lesson/7859/step/4?unit=1351)

`max 5 42` вернёт `42` можно записать как `(max 5) 42` и тоже вернёт `42` -- операция применения функции ассоциативна влево. `(max 5)` называется частичным применением функции, результат работы выражения функция одного аргумента и может быть применена там, где требуется функция одного аргумента. 

В общем виде частичное применение функций можно сформулировать как применение функции от n переменных, но с точки зрения функции от одной переменной, но применённой n раз. Каждое применение такой функции будет возвращать функцию от n - 1 переменной.

### [Шаг 1.2.5](https://stepik.org/lesson/7859/step/5?unit=1351)

В стандартной библиотеке Haskell есть функция вычисления логарифма по произвольному основанию `logBase`. Это функция двух переменных, которой требуется передать основание логарифма и аргумент, на котором логарифм будет вычислен. Какие из следующих вызовов обеспечат вычисление логарифма по основанию 2 от 8?

- [+] (logBase 2) 8
- [-] logBase (2 8)
- [-] logBase (2, 8)
- [+] logBase 2 8
- [-] (logBase, 2, 8)

### [Шаг 1.2.6](https://stepik.org/lesson/7859/step/6?unit=1351)

Чтобы определить функцию нужно: задать её имя, указать параметры, поставить знак равенства и после знака равенства реализовать тело функции. Пример функции:

```haskell
sumSquares x y = x ^ 2 + y ^ 2
```

Регистр важен. Имя функции и параметры должны начинаться с символа в нижнем регистре. Символы в вернхнем регистре служат для определения типов данных.

В Haskell возможны имена включащие в себя `'`

Чтобы определить функцию в GHCi нужно использовать ключевое слово `let` перед именем функции.

### [Шаг 1.2.7](https://stepik.org/lesson/7859/step/7?unit=1351)

Реализуйте функцию трех аргументов `lenVec3`, которая вычисляет длину трехмерного вектора. Аргументы функции задают декартовы координаты конца вектора, его начало подразумевается находящимся в начале координат. Для извлечения квадратного корня воспользуйтесь функцией `sqrt`, определенной в стандартной библиотеке.

```haskell
GHCi> lenVec3 2 3 6
7.0
```

#### Решение 1.2.7

```haskell
lenVec3 x y z =  sqrt (x ^ 2 + y ^ 2 + z ^ 2)
```

### [Шаг 1.2.8](https://stepik.org/lesson/7859/step/8?unit=1351)

Важная отличительна черта функциональных языков это чистые функции. Функции чистые, т.е. не имеют внешних эффектов и определяются только её аргументами.

Функция, которая не принимает аргументов, это константа или константная функция. 

### [Шаг 1.2.9](https://stepik.org/lesson/7859/step/9?unit=1351)

Пример условного выражения `f x = if x > 0 then 1 else (-1)`

Отрицательные числа следует заключать в скобки

В Haskell обе ветви условного выражения должны присутствовать. В ветвях должны быть выражения одного и того же типа. 

### [Шаг 1.2.10](https://stepik.org/lesson/7859/step/10?unit=1351)

Напишите реализацию функции `sign`, которая возвращает 1, если ей передано положительное число, (-1), если отрицательное, и 0 в случае, когда передан 0.

```haskell
GHCi> sign (-100)
-1
```

#### Решение 1.2.10

```haskell
sign x = if x > 0 then 1 else if x == 0 then 0 else (-1)
```

### [Шаг 1.2.11](https://stepik.org/lesson/7859/step/11?unit=1351)

Механизм определения функций с помощью частичного применения

```haskell
max5 x = max 5 x
--- Эквивалентен
max5` = max 5 
--- max5' это частично применённая функция max
```

Подобный стиль называется бесточечным.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
```

В Haskell часто специально проектируют функции, чтобы их было проще применять частично. В функции `discount` параметры `proc` и `limit` меняются крайне редко, а вот `sum` постоянно.

```haskell
--- Функция расчёта скидки выше некоего предела
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
--- Функция определения стандартной скидки.
standardDiscount = discount 1000 5
```

Функция `standardDiscount` определена как частичная, т.к. параметр `sum` опущен. Теперь Функция `standardDiscount` может быть вызвана с одним параметром. 

### [Шаг 1.2.12](https://stepik.org/lesson/7859/step/12?unit=1351)

Предположим, мы разрабатываем на Haskell интерфейс системы перевода для естественных языков. Он должен содержать функцию `translate` с параметрами `text`, `languageFrom` и `languageTo`. Расположите параметры в таком порядке, чтобы было удобно реализовывать следующие функции: `translateFromSpanishToRussian`, `translateFromEnglishToRussian` и `translateToRussian`.

- [+] translate languageTo languageFrom text
- translate text languageFrom languageTo
- translate languageTo text languageFrom
- translate languageFrom languageTo text
- translate text languageTo languageFrom
- translate languageFrom text languageTo

Поставить параметр `languageTo` первым, т.к. все три функции переводят на русский язык.

Поставить параметр `languageFrom` вторым, т.к. `FromSpanish`, `FromEnglish` и в последнем язык случае с какого языка будет происходить перевод вообще явно не определён.

Поставить параметр `text` в конце, т.к. он постоянно меняется. Частичное применение. 

## Урок 1.3 Операторы

### [Шаг 1.3.2](https://stepik.org/lesson/8411/step/2?unit=1550)

Функции вызываются в префиксном стиле, т.е. функция идёт перед своими аргументами, а операторы в инфиксном стиле, т.е. оператор находится между своими аргументами. Это различие можно убрать и начать вызывать операторы в префиксном стиле и функции в инфиксном. Для этого нужно поместить функцию между аргументами и заключить в обратные ковычки, операторы нужно заключить в скобки и поставить перед аргументами. 

```haskell
max 6 7
6 `max` 7
--
6 + 7
(+) 6 7
```

Все операторы в Haskell бинарные, т.е. принимают два аргумента. Кроме унарного префиксного минуса, который служить для создания отрицательных чисел.

### [Шаг 1.3.3](https://stepik.org/lesson/8411/step/3?unit=1550)

Применение функции имеет наивысший приоритет равный 10.

Для установки приоритета и ассоциативность служат следующие ключевые слова:
- `infixl` -- левоассоциативность
- `infixr` -- правоассоциативность
- `infix` -- без указания характера ассоциативности
- затем указывается число от 1 до 10
- и в конце имя оператора

```haskell
-- Пример из стандартной библиотеки 
infixr 8 ^, `logBase`
infixl 7 *, /, `div`, `mod`
infixl 6 +, -
infix 4 ==, /=, >, >=, <, <=
```

По-умолчанию в Haskell принята левоассоциативность и приоритет 9.

### [Шаг 1.3.4](https://stepik.org/lesson/8411/step/4?unit=1550)

Попробуйте вычислить значение выражения `2 ^ 3 ^ 2`, не используя GHCi.

#### Решение 1.3.4

```
2 ^ 3 ^ 2
~> 2 ^ 9
~> 512
```

### [Шаг 1.3.5](https://stepik.org/lesson/8411/step/5?unit=1550)

Попробуйте вычислить значение выражения `(*) 2 ((+) 1 4) ^ 2`, не используя GHCi.

#### Решение 1.3.5

```
(*) 2 ((+) 1 4) ^ 2
~> (*) 2 5 ^ 2
~> 10 ^ 2 = 100
```

### [Шаг 1.3.6](https://stepik.org/lesson/8411/step/6?unit=1550)

В Haskell нет встроенных операторов. 

Список символов, из которых можно составить собственные операторы: `! # $ % & * + . / < = > & @ \ ^ | - ~`

Пример собственного оператора: 

```haskell
infixl 6 *+*

-- В инфиксной нотации или операторном стиле
a *+* b = a ^ 2 + b ^ 2
-- В префиксной нотации или в функциональном стиле
(*+*) a b = a ^ 2 + b ^ 2
```

### [Шаг 1.3.7](https://stepik.org/lesson/8411/step/7?unit=1550)

Используя данное выше определение оператора `(*+*)`:

```haskell
infixl 6 *+*
(*+*) a b = a ^ 2 + b ^ 2
```

попробуйте устно вычислить значение выражения `1 + 3 *+* 2 * 2`.

#### Решение 1.3.7

```
1 + 3 *+* 2 * 2
~> 1 + 3 *+* 4
~> 4 *+* 4 
~> 4 ^ 2 + 4 ^ 2 = 16 + 16 = 32
```

### [Шаг 1.3.8](https://stepik.org/lesson/8411/step/8?unit=1550)

Реализуйте оператор `|-|`, который возвращает модуль разности переданных ему аргументов:

```haskell
GHCi>  5 |-| 7
2
```

#### Решение 1.3.8

```haskell
{-
Реализуйте оператор |-|, который возвращает модуль разности переданных ему аргументов:

GHCi>  5 |-| 7
2
-}
x |-| y = if x - y >= 0 then x - y else y - x
-- x |-| y = abs (x - y)
```

### [Шаг 1.3.9](https://stepik.org/lesson/8411/step/9?unit=1550)

Специальный компактный синтаксис частичного применения оператора к одному из своих аргументов.

```haskell
-- Сечение оператора. Связывание слева.
(2 /) 4
-- Вернёт 0.5 как ожидалось.

-- Сечение оператора. Связывание справа.
(/ 2) 4
-- Вернёт 2.0 как ожидалось.
```

Подобный синтаксис требует обязательного использования круглых скобок. Оператор унарный минус `(-)` является исключением.

### [Шаг 1.3.10](https://stepik.org/lesson/8411/step/10?unit=1550)

Попробуйте вычислить значение выражения `('mod' 14) ((+ 5) 10)`, не используя GHCi. (Функция `mod` возвращает остаток от целочисленного деления первого своего аргумента на второй.)

#### Решение 1.3.10

```
('mod' 14) ((+ 5) 10)
~> ('mod' 14) 15
~> 15 mod 14 = 1
```

### [Шаг 1.3.11](https://stepik.org/lesson/8411/step/11?unit=1550)

Оператор `$`. Его приоритет равен 0 и правоассоциативный. Он используется для избавления от избыточных скобок. 

Записи `sin 0` и `sin $ 0` эквивалетны.

Запись `sin (pi / 2)` можно упростить с помощью оператора `$` и записать как `sin $ pi / 2`.

`f (g x (h y))` == `f $ g x (h y)` == `f $ g x $ h y`

#### [Шаг 1.3.12](https://stepik.org/lesson/8411/step/12?unit=1550)

Используя оператор `$`, перепишите выражение `logBase 4 (min 20 (9 + 7))` без скобок. (Разделяйте все токены одним пробелом.)

##### Решение 1.3.12

```haskell
logBase 4 $ min 20 $ 9 + 7
```

## Урок 1.4 Базовые типы

## Урок 1.5 Рекурсия

## Урок 1.6 Локальные связывания и правила отступов 
